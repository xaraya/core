Notes on different backends and their capabilities.

Documentation references:
-------------------------
- mysql   : http://dev.mysql.com/doc/refman/5.1/en
- sqlite  : http://sqlite.org/lang.html
- postgres: http://developer.postgresql.org/pgdocs/postgres/
- mssql   : http://msdn2.microsoft.com/en-us/library/ms189826.aspx
- oracle  : http://download-uk.oracle.com/docs/cd/B19306_01/server.102/b14200/toc.htm

VIEWS support
-------------
- mysql   : yes, since 5.0
- sqlite  : yes, since forever, but read only (which is a good thing,  but a pain when you're migrating )
- postgres: yes, since 7.3 (at least)
- mssql   : yes, no idea version wise
- oracle  : ?
  
==> SUPPPORTED BY ALL, WORTH CONSIDERING

TRANSACTION support
-------------------
- mysql   : yes, innodb engine only ( gracefull fallback provided by middleware?)
- sqlite  : yes, since forever
- postgres: yes
- mssql   : yes
- oracle  : ?

==> SUPPORTED BY ALL, BEING USED RIGHT NOW.

NESTED TRANSACTION support:
---------------------------
- mysql   : NO (see http://dev.mysql.com/doc/refman/5.1/en/commit.html )
- sqlite  : NO
- postgres: NOT BEFORE 7.5 at least
- mssal   : YES ( see http://www.codeproject.com/database/sqlservertransactions.asp )
- oracle  : YES 

==> We have to make sure we have only one transaction active at any given time
Having multiple transactions active is hidden by creole by just not committing
until the transactioncount reached zero again. This will not work in cases where the 
sequence of code doing database operations has a functional dependency, unless these
dependencies are all in the same transaction. This can lead to very confusing errors
while running the code. Seemingly random/ad-hoc errors start to appear. The exact logic is
hard to describe and can differ between backends. (mysql does an auto commit for an 
active transaction when a new one is started for example, while others do not)

We could consider:
-> raising an exception during development phase when 2 transactions are active
-> keep current creole behaviour and watch logs (there are clearly greppable log statements issued)


FOREIGN KEY support
-------------------
- mysql   : yes, innodb engine only
- sqlite  : no, accepts syntax, but doesnt act (triggers is the proposed alternative)
- postgres: yes
- mssql   : yes, no idea version wise
- oracle  : ?

Foreign key constrained columns can be NULL?
--------------------------------------------
- mysql   : yes 
- sqlite  : yes (n/a, needs to be handled by trigger)
- postgres: yes
- mssql   : ?
- oracle  : ?
[Note: this is important to know because we encode 'none' and 'empty' with null, so
if that meaning is not correct, the on update/delete etc. trigger either need to
prevent it or take another appropriate action to make sure if the action is valid the
constraints are met]

HASH index support
------------------
- mysql   : yes, memory tables only, only used for equality tests (obviously) 
- sqlite  : no
- postgres: 
- mssql   : 
- oracle  : 

IN MEMORY TABLE support
-----------------------
- mysql   : yes 
- sqlite  : yes, in memory databases only
- postgres: 
- mssql   : 
- oracle  : 

IN MEMORY DATABASE support
--------------------------
- mysql   :  
- sqlite  : yes
- postgres: 
- mssql   : 
- oracle  : 

TRIGGER support
---------------
- mysql   : yes, since 5.0.2
- sqlite  : yes, since forever
- postgres: yes, at least since 7.3
- mssql   : yes, at least since mssql server 2000
- oracle  : ?

==> SUPPORTED BY ALL, WORTH CONSIDERING

TRIGGER SYNTAX
--------------
mysql:
        CREATE TRIGGER someTriggerName BEFORE INSERT ON sometable
        FOR EACH ROW
        BEGIN
            SET NEW.guid = UUID();
        END
        --> no instead of trigger (no need)
        --> only before insert, not after insert

sqlite:
        // This trigger runs instead of the supplied statement to
        // workaround the read-only limitation of a view
        CREATE TRIGGER someTriggerName INSTEAD OF INSERT ON SomeView
        [FOR EACH ROW]
        BEGIN
            INSERT INTO RealTable 
            VALUES( NEW.fieldName1, NEW.FieldName2,...,NEW.FieldNameN);
        END;

        // This trigger runs when an update occurs on sometable.somefield
        CREATE TRIGGER someTriggerName AFTER UPDATE OF somefield ON  sometable
        [FOR EACH ROW]
        BEGIN
            UPDATE someOtherTable SET someOtherField = NEW.somefield 
            WHERE someOtherTable.YetAnotherField = OLD.AgainSomethingElse;
        END;

        The trick is the new an old designators obviously
        -> on update NEW and OLD are valid
        -> on insert NEW is valid
        -> on delete OLD is valid
        -> only FOR EACH ROW triggers (the default also)

Native query preparation support
--------------------------------
- sqlite    : no
- mysql     : yes, since 4.1.3 at SQL level (no api)

              PREPARE <stmtname> FROM <query>
              SET @bindvar_1 = value_1
              ...
              SET @bindvar_n = value_n
              EXECUTE <stmtname> USING @bindvar_1,...,@bindvar_n

- mysqli    : php >= 5 has api

                $mysqli = new mysqli('localhost', 'my_user', 'my_password', 'world');
                $stmt   = $mysqli->prepare("INSERT INTO CountryLanguage VALUES (?, ?, ?, ?)");
                $stmt->bind_param('sssd', $code, $language, $official, $percent);
                $stmt->execute();
                $stmt->close();

                Seems that the resultset returned with this new interface is not compatible
                with the old resultset!!!!!
- pgsql    :    yes, both at SQL and PHP level

                SQL level:
                    PREPARE <plan-name> AS <query without bindvars>
                    EXECUTE <plan-name> 
                    PREPARE <plan-name> (datatype_1,...,datatyp_n) AS <query with bindvars>
                    EXECUTE <plan-name> value_1,...,value_n

                PHP level:
                    $conn = pg_connect("dbname=mary");

                    $result = pg_prepare($dbconn, "my_query", 'SELECT * FROM shops WHERE name = $1');
                    $result = pg_execute($dbconn, "my_query", array("Joe's Widgets"));
                    $result = pg_execute($dbconn, "my_query", array("Clothes Clothes Clothes"));
- mssql     :    Unknown, it's possible in embedded SQL, no idea if transact SQL does support it.
- oracle    :     most likely


Comments Syntax support for SQL:
  
- mysql   : /*..*/, --, #
- pgsql   : /*..*/, --
- sqlite  : /*..*/, --
- oracle  : /*..*/       
- mssql   : /*..*/       

==> Recommended : /* ... */

Datatype notes:

Acceptance in SQL: 
(NOTE: means nothing about actual storage and how it behaves, just means SQL doesnt produce an error)

                                          mysql   pgsql   sqlite    oracle   mssql
    tinyint                                X       -        X         X        X
    smallint                               X       X        X         X        X
    mediumint                              X       -        X         -        -
    bigint                                 X       X        X         X        X
    int                                    X       X        X         -        X
    integer                                X       X        X         X        -
       
    bit                                    X       X        X         X        X
    bool                                   X       -        X         -        -
    boolean                                X       X        X         -        -

    float                                  X       -        X         X        X
    double [precision]                     X       X        X         X        X
    real                                   -       X        X         X        X

    decimal                                X       X        X         X        X
    numeric                                X       X        X         X        X
    dec                                    X       -        X         -        -
    fixed                                  X       -        X         -        -

    char                                   X       X        X         X        X
    varchar                                X       X        X         X        X   
    longvarchar                            -       -        X         X        -
    text                                   X       X        X         -        X
    tinytext                               X       -        X         -        -
    mediumtext                             X       -        X         -        -
    longtext                               X       -        X         -        -

    money                                  -       X        X         -        X
    smallmoney                             -       -        X         -        X

    date                                   X       X        X         X        -
    datetime                               X       X        X         -        X
    smalldatetime                          -       -        X         -        X 
    timestamp                              X       X        X         X        X
    interval                               -       X        X         -        -
    time                                   X       X        X         X        -
    year                                   X       -        X         -        -

    binary                                 X       -        X         X        X
    bytea                                  -       X        X         -        -
    varbinary                              X       -        X         X        X
    long varbinary                         X       -        X         X        -
    image                                  -       -        X         -        X
    blob                                   X       -        X         -        -
    tinyblob                               X       -        X         -        -
    mediumblob                             X       -        X         -        -
    longblob                               X       -        X         -        -

    rowid                                  -       -        X         X        -
    serial                                 -       X        X         -        -
    bigserial                              -       X        X         -        -




ID generation revisited
-----------------------
I've never understood our current solution for dealing with IDs and why it 
evolved into what it is now. What follows is how I think it should be done. We
can revisit this at an appropriate time.

The main problem:
    Some databases have a native type to generate auto incrementing values
    transparently, while others use triggers or sequences to make it somewhat
    less transparent. The main problem lies in the question on how to abstract
    both in the same way.
    
Current concept:
    - call genID before and insert, that delivers something back (no matter what it is)
    - call a SQL insert statement, putting whatever genID delivered back in the place
    of the column which should hold the ID
    - when needed call PO_Insert_ID to retrieve the actual value (and pray it 
    is the right one) of the ID used.
    
Problems with this concept:
    - the genID call is useless, it generates nothing for auto increment type 
    systems and advances the sequence for sequence based systems too early, 
    thus creating a dependency  (i.e. you really cant call genID, wait for some 
    user input for example and then go on, you  basically need to do the insert 
    right away and hope you do it fast enough)
    - the insert touches an ID column, allowed of course, and needed in our 
    concept but it doesnt serve any purpose, as you cant influence it anyways
    - the PO_Insert_ID implementation is a hack and unreliable, especially in 
    high concurrency environments. (it uses select max(id) which may have been 
    advanced to 10 ids further on by the time you're calling it.)
    

Alternative concept:
    The distinction between the two types of backends is nothing we can do 
    about, it's a given.
    
    My ideal concept would be:
    - call a SQL insert statement
    - retrieve reliably the last inserted ID value if you need it.
    
    For this to work a number of things need to be taken care of:
    
    Let's use this example table [pseudo-ddl]:
    create table test {
        id the_autoinc_type,
        name string
        primary key(id)
    }
    which is roughly how we use it everywhere.
    
    1. the insert SQL should omit the ID column and responsibility of creating 
    values for it transferred to the backend, 
    Thus this:
        insert into test(id,name) values(genID(),'thename')
    becomes:
        insert into test('thename')
       
    For this to work in both type of backends, both should be able to generate
    their id's automatically and transparently. For the auto increment types
    this is easy, because that type was invented to do just that if you omit
    the column or put a 0 or NULL into it. 
    
    2. For the sequence based backends you explicitly have to tell the database 
    to do it (same concept, but explicitly needed)
    Say, for postgres, which is sequence based, this translates to:
        create sequence test_id_seq;
        create table test {
            id integer NOT NULL DEFAULT nextval('test_id_seq'),
            name string
            primary key(id)
        }
        [in recent versions: use the serial native type, which is almost equivalent]

    3. the last insert id retrieval needs to be reliable.
    Again, for the auto increment type backend, there is usually an SQL construct
    or API function which does exactly that. Similarly, for the sequence based
    system, there are either SQL or API constructs to get the same information
    from the sequence.
        Examples:
            mysql: SELECT LAST_INSERT_ID() 
            (not completely safe, because it is global on the session)
            
            postgres: SELECT curval('test_id_seq')
    
    For the sequence based systems this is safe, as it only considers the 
    current session.
    
As we use the genID like a million times all over this saves a whole lot of 
code and makes everything simpler and more reliable in my opinion.

Does this work for all databases? Here's an overview 

- mysql :   no changes required to the db model in use now
- sqlite:   no changes required to the db model in use now
- postgres: either use the serial datatype where an autoincrement is needed (recommended)
            or define the sequence explicitly and the column too
- oracle:   define the sequence and either use a before insert trigger or 
            the definition of the default value on the sequence (not sure if that is supported)
- mssql   : not sure, mssql has both sequences and autoincrement type, in theory
            no changes are needed
Inventory:
----------
Usage of PO_Insert_ID in core:

$ grep -ril PO_insert_ID *
creole/common/ConnectionCommon.php
includes/datastores/sql/flattable.php
includes/tmtags
modules/base/xarinit.php
modules/dynamicdata/xarinit.php
modules/blocks/xaradminapi/create_group.php
modules/blocks/xaradminapi/create_instance.php
modules/blocks/xaradminapi/create_type.php
modules/roles/class/xarQuery.php
modules/modules/xarinit.php

