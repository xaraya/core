<?xml version="1.0" encoding="utf-8"?>
<xar:template xmlns:xar="http://xaraya.com/2004/blocklayout">
    <!-- License: GPL http://www.gnu.org/copyleft/gpl.html -->
    <xar:style scope="theme" file="navtabs"/>
    <xar:set name="dummy">xarVarFetch('tab', 'pre:trim:lower:str:1:', $tab, '', XARVAR_NOT_REQUIRED)</xar:set>
    <xar:set name="activetab">'xar-tab-active'</xar:set>
    <xar:set name="activelink">'xar-accent xar-accent-outline'</xar:set>
    <xar:set name="inactivetab">'xar-tab'</xar:set>
    <xar:set name="inactivelink">'xar-norm xar-norm-outline'</xar:set>
    <xar:template file="user-mod-head"/>
    <div class="xar-mod-body">
        <h2>EventSystem Scenario</h2>
        <p>The event system is used by packages of Xaraya to trigger certain events in the system. These events are dispatched to the active modules which may define special functions that can act on those events.</p>
        <p>NOTE: The event system is distinct from hooks in that events belonging to the event system are guaranteed to happen, unlike hooks which may, or may not have been configured by the site administrator.</p>
        <div>
            <ul class="xar-tabs xar-alt xar-norm-outline">
                <xar:set name="tabclass">empty($tab)?$activetab:$inactivetab</xar:set>
                <xar:set name="linkclass">empty($tab)?$activelink:$inactivelink</xar:set>
                <li class="#$tabclass#">
                    <a href="#xarServer::getCurrentUrl(array('tab' => null))#" title="#xarML('Overview')#" class="#$linkclass#">
                    Overview</a>
                </li>
                <!--
                <xar:set name="tabclass">$tab=='functions'?$activetab:$inactivetab</xar:set>
                <xar:set name="linkclass">$tab=='functions'?$activelink:$inactivelink</xar:set>
                <li class="#$tabclass#">
                    <a href="#xarServer::getCurrentUrl(array('tab' => 'functions'))#" title="#xarML('Functions')#" class="#$linkclass#">
                    Functions</a>
                </li>
                <xar:set name="tabclass">$tab=='subjects'?$activetab:$inactivetab</xar:set>
                <xar:set name="linkclass">$tab=='subjects'?$activelink:$inactivelink</xar:set>
                <li class="#$tabclass#">
                    <a href="#xarServer::getCurrentUrl(array('tab' => 'subjects'))#" title="#xarML('Subjects')#" class="#$linkclass#">
                    Subjects</a>
                </li>
                <xar:set name="tabclass">$tab=='observers'?$activetab:$inactivetab</xar:set>
                <xar:set name="linkclass">$tab=='observers'?$activelink:$inactivelink</xar:set>
                <li class="#$tabclass#">
                    <a href="#xarServer::getCurrentUrl(array('tab' => 'observers'))#" title="#xarML('Observers')#" class="#$linkclass#">
                    Observers</a>
                </li>
                <xar:set name="tabclass">$tab=='examples'?$activetab:$inactivetab</xar:set>
                <xar:set name="linkclass">$tab=='examples'?$activelink:$inactivelink</xar:set>
                <li class="#$tabclass#">
                    <a href="#xarServer::getCurrentUrl(array('tab' => 'examples'))#" title="#xarML('Examples')#" class="#$linkclass#">
                    Examples</a>
                </li>
                -->
            </ul>
        </div>
        <xar:if condition="empty($tab)">

<h2>Concepts</h2>

<p>The Xaraya event system as it currently stands deals with system level events. That is events which happen during loading of the core. </p>

<p>The Xaraya hook system as it currently stands deals with module level events. That is events which happen during the course of a modules operation. </p>

<p>The *only* difference between the two systems is that events are guaranteed to be notified to all observers, regardless of intervention by the Xaraya admin, whereas hooks can be configured in the UI. </p>

<p>That difference boils down to where the list of observers comes from. For the event system itself, that is all observers it knows about for the signalled event, and for hooks it is all modules hooked to a given module/itemtype with an observer for the signalled event (hook scope/type).</p>

<p>The workflow is as follows for both system, it conforms to a standard subject/observer pattern.</p>

<ol><li>Event (subject) is raised by caller (xarEvents::notify() or xarModCallHooks())</li>
<li>Listeners (observers) are retrieved and notified</li>
<li>Response is returned to caller</li></ol>


<h3>Aims</h3>
<ul>
<li>Replace the underlying code with a solid api.</li>
<li>Provide a means for other systems using the same pattern (eg, hooks) to leverage and/or extend that api with minimal code.</li>
</ul>

<h3>Event System</h3>

<p>In order for the event system to function it needs to know two things. </p>
<ol>
<li>The list of subjects available</li>
<li>The list of observers available for those subjects</li>
</ol>
<p>In the existing system, subjects are registered on the fly during page load, and observers are obtained from a config var, which is itself generated by looking for specific files and functions in the file system.</p>

<p>In the new system, a db table is provided, and both subjects and observers are registered during module init. Because subjects and observers share the same properties, they can co-exist in the same table by each belonging to a distinct itemtype.</p>


<h3>Subjects</h3>

<p>In the existing system, subjects are registered on the fly, they only indicate an event exists, and provide no other information to the event system.</p>

<p>In the new system, subjects are registered into the db. Not only do they indicate an event exists, they serve as a pointer to a file in the file system. This file can be thought of as the event definition. The subject file must exist and its whereabouts must be registered in the event system. It is the responsibility of the event subject to supply any additional information needed by it's observers, eg as arguments, class properties, or methods.</p>

<p>In both systems each event must be unique.</p>

<h4>Registering Subjects</h4>

<p>When registering a subject the following function is called</p>

<code><pre>
    xarEvents::registerSubject($event,$scope,$module,$area='class',$type='eventsubjects',$func='notify')

    The parameters define the event name and where the event system will look for the subject file

    @event, string, name of the event, required, must be unique
    @scope, string, the scope of the event (Server, Session, Module, User, Item, etc, etc..), required
    @module, string, the name of the module the file can be found in, required
    @area, string, the area in which the file can be found, either api or class, default class
    @type, string, if area is api the type of api function (user, admin, etc) or 
                   if area is class the name of a subfolder in /module/class/, default eventsubjects
    @func, string, if area is api, the name of the function to call, defaults to strtolower(event)
                   if area is class, the name of the method to call, default is notify
</pre></code>
          
<h4>Class subjects</h4>

<p>Subject class names must always be defined as follows</p>

<code><pre>
    ucfirst(module) . event . "Subject", eg BaseSessionCreateSubject
</pre></code>

<p>All subject classes must implement ixarEventSubject interface (see xaraya.structures.events.subject)</p>
<ol>
<li>xarEvents::notify('event', $args) is called</li>
<li>The event system instantiates the event subject, passing args (if any) to constructor.</li>
<li>The event system retrieves, instantiates and attaches class observers to the subject.</li>
<li>The event system calls the method ($func defined when subject was registered)</li>
<li>The subject class is responsible for notifying each of those observers and handling any responses. </li>
<li>The subject class is responsible for returning any response to the event system.</li>
<li>The event system is responsible for returning response (if any) to the caller.</li>
</ol>

<h4>API subjects</h4>

<p>This is basically by-passing the event system and calling an api function. The api function itself is responsible for retrieving and notifying its observers, and returning a response (if any) to the event system. Observers of API subjects may or may not be registered in the event system, it is up to the API function to retrieve them from wherever it was designed to store them</p>. 
<ol>
<li>xarEvents::notify('event', $args) is called</li>
<li>The event system calls the api function passing it args (if any) and returns the response (if any) to the caller.</li>
</ol>


<p>Some class subject registration examples</p>

<code><pre>
xarEvents::registerSubject('MyEvent','MyItems','mymodule');
</pre></code>
<ul>
<li>will look for class MymoduleMyEventSubject</li>
<li>with a method of notify()</li>
<li>in file code/modules/mymodule/class/eventsubjects/myevent.php</li>
</ul>
<code><pre>
xarEvents::registerSubject('MyOtherEvent','MyOtherItems','mymodule', 'class', 'mysubjects', 'alert');
</pre></code>
<ul>
<li>will look for class MymoduleMyOtherEventSubject</li>
<li>with a method of alert()</li>
<li>in file code/modules/mymodule/class/mysubjects/myotherevent.php</li>
</ul>

<p>Some api subject registration examples</p>

<code><pre>
xarEvents::registerSubject('MyAPIEvent','MyItems','mymodule', 'api', 'user');
</pre></code>
<ul>
<li>will look for function mymodule_userapi_myapievent() </li>
<li>in file code/modules/mymodule/xaruserapi/myapievent.php</li>
<li>falling back to code/modules/mymodule/xaruserapi.php</li>
</ul>
<code><pre>
xarEvents::registerSubject('MyOtherAPIEvent','MyOtherItems','mymodule', 'api', 'admin', 'alert');
</pre></code>
<ul>
<li>will look for function mymodule_adminapi_alert() </li>
<li>in file code/modules/mymodule/xaradminapi/alert.php</li>
<li>falling back to code/modules/mymodule/xaradminapi.php</li>
</ul>

<h3>Observers</h3>

<p>In the existing system observers are 'registered' by the system itself. An api function is called which traverses the filesystem looking for matching module observers (xareventapi functions)</p>

<p>In the new system, observers are registered into the db. Not only do they indicate an observer exists, they serve as a pointer to a file in the file system. The observer file must exist and its whereabouts must be registered in the event system. It is the responsibility of the observer to be aware of the requirements of the subject it's observing. </p>

<p>In both systems each observer must be unique to the module providing it (that is, you can't register two observers of the same event subject in one module)</p>

<h4>Registering Observers</h4>

<p>When registering observers the following function is called...</p>
<code><pre>
    xarEvents::registerObserver($event,$module,$area='class',$type='eventobservers',$func='notify')

    The parameters define the event being observed and where the event system will look for the observer file

    @event, string, name of the event, required, must be unique
    @module, string, the name of the module the file can be found in, required
    @area, string, the area in which the file can be found, either api, gui or class, default class
    @type, string, if area is api or gui the type of api function (user, admin, etc) or 
                   if area is class the name of a subfolder in /module/class/, default eventsubjects
    @func, string, if area is api or gui, the name of the function to call, defaults to strtolower(event)
                   if area is class, the method is always notify
</pre></code>

<h4>Class Observers</h4>

<p>Observer class names must always be defined as follows</p>

<code><pre>
    ucfirst(module) . event . "Observer", eg RolesSessionCreateObserver
</pre></code>

<p>All observer classes must implement ixarEventObserver interface (see xaraya.structures.events.observer)</p>

<p>It is the responsibility of the observer to be aware of expected parameters from the subject it's observing, and return a valid response (if any) to the subject. It must supply a notify method which will be called by the event subject. </p>

<h4>API and GUI Observers</h4>

<p>The event system wraps API and GUI observers in a class for compatibility with event subjects, calling the api or gui function and passing args from the subject (if any) and returning a response (if any) to the subject. This only applies to observers of class subjects.</p>


<p>Some class observer registration examples</p>

<code><pre>
xarEvents::registerObserver('MyEvent','mymodule');
</pre></code>
<ul>
<li>will look for class MymoduleMyEventObserver</li>
<li>with a method of notify()</li>
<li>in file code/modules/mymodule/class/eventobservers/myevent.php</li>
</ul>
<code><pre>
xarEvents::registerObserver('MyOtherEvent', 'mymodule', 'class', 'myobservers');
</pre></code>
<ul>
<li>will look for class MymoduleMyOtherEventObserver</li>
<li>with a method of notify()</li>
<li>in file code/modules/mymodule/class/myobservers/myotherevent.php</li>
</ul>
<p>Some api and gui observer registration examples</p>

<code><pre>
xarEvents::registerObserver('MyAPIEvent', 'mymodule', 'api', 'user');
</pre></code>
<ul>
<li>will look for function mymodule_userapi_myapievent() </li>
<li>in file code/modules/mymodule/xaruserapi/myapievent.php</li>
<li>falling back to code/modules/mymodule/xaruserapi.php</li>
</ul>
<code><pre>
xarEvents::registerObserver('MyGUIEvent', 'mymodule', 'gui', 'admin', 'alert');
</pre></code>
<ul>
<li>will look for function mymodule_admin_alert() </li>
<li>in file code/modules/mymodule/xaradmin/alert.php</li>
<li>falling back to code/modules/mymodule/xaradmin.php</li>
</ul>
<!--
        <xar:elseif condition="$tab eq 'subjects'"/>
            <h2>Event Subjects</h2>
            <p>Event subjects can be thought of as the definitions of events.</p>
            <h3>Requirements</h3>
            <ul>
                <li>Event subjects must be unique.</li>
                <li>All event subjects must be registered into the EMS.</li>
                <li>All event subjects must have a corresponding subject file.</li>            
            </ul>
            <h3>Class Type Event Subjects</h3>
            <p>As the name suggests, the event subject is contained in a class.</p>
<code><pre>
sys::import('xaraya.structures.descriptor');
class EventSubject extends ObjectDescriptor implements ixarEventSubject
{
    // protected $args = array();      // from descriptor    
    protected $observers = array(); // xarEvents::notify is responsible for populating this array 
    protected $subject = 'Event';   // name of this event subject
     
    public function __construct($args=array())
    {
        parent::__construct($args); // $this->setArgs($args);                              
    }

    public function notify()
    {
        foreach ($this->observers as $obs) {
            $response = $obs->notify($this);
        }
    }
    
    public function attach(ixarEventObserver $obs)
    {
        $id = $obs->module;
        $this->observers[$id] = $obs;
    }
    
    public function detach(ixarEventObserver $obs)
    {
        $id = $obs->module;
        if (isset($this->observers[$id]))
            unset($this->observers[$id]);    
    }
    
    public function getSubject()
    {
        return $this->subject;
    }
}
</pre></code>
                           
        <xar:elseif condition="$tab eq 'examples'"/>
            <h3>Examples</h3>
            
        <xar:else/>
-->        
        </xar:if>                
    </div>
    <div class="xar-mod-foot">
        <p class="xar-align-center">Document Version 2.0: 03 Oct 2010</p>
    </div>
</xar:template>